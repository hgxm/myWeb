//
//  SetDrawLine.m
//  BigClassRoom
//
//  Created by apple  on 13-1-10.
//
//

#import "SetDrawLine.h"

@implementation SetDrawLine
@synthesize setDelegate;
@synthesize width,currcolor;
- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        // Initialization code
        
        width=2.0;
        
        arrColors=[[NSArray alloc] initWithObjects:[UIColor blackColor],[UIColor redColor],[UIColor greenColor],[UIColor blueColor],[UIColor yellowColor],[UIColor magentaColor],[UIColor purpleColor],[UIColor orangeColor], nil];
        
        UIImageView *backViewImage=[[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.frame.size.width, self.frame.size.height)];
        backViewImage.image=[UIImage imageNamed:@"画笔背景.png"];
        backViewImage.userInteractionEnabled=YES;
        [self addSubview:backViewImage];
        [backViewImage release];
        
        UIPanGestureRecognizer *panGestureBack = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panGestureBack:)];
        [panGestureBack setMaximumNumberOfTouches:2];
        [backViewImage addGestureRecognizer:panGestureBack];
        [panGestureBack release];
        
        
        UILabel *lbl1=[[UILabel alloc]initWithFrame:CGRectMake(10, 20, 100, 25)];
        lbl1.text=@"换笔设置";
        lbl1.backgroundColor=[UIColor clearColor];
        lbl1.textColor=[UIColor whiteColor];
        lbl1.font=[UIFont boldSystemFontOfSize:15];
        lbl1.textAlignment=NSTextAlignmentLeft;
        [self addSubview:lbl1];
        [lbl1 release];
        
        UIButton *closeBtn=[[UIButton alloc]initWithFrame:CGRectMake(self.frame.size.width-50, 15, 32, 32)];
        closeBtn.backgroundColor=[UIColor clearColor];
        [closeBtn addTarget:self action:@selector(closeBtnAction) forControlEvents:UIControlEventTouchDown];
        [closeBtn setImage:[UIImage imageNamed:@"关闭按钮.png"] forState:UIControlStateNormal];
        [self addSubview:closeBtn];
        [closeBtn release];
        
        UILabel *lbl2=[[UILabel alloc]initWithFrame:CGRectMake(15, 60, 100, 25)];
        lbl2.text=@"画笔预览";
        lbl2.backgroundColor=[UIColor clearColor];
        lbl2.textColor=[UIColor whiteColor];
        lbl2.font=[UIFont boldSystemFontOfSize:13];
        lbl2.textAlignment=NSTextAlignmentLeft;
        [self addSubview:lbl2];
        [lbl2 release];
        
        
        UILabel *lbl3=[[UILabel alloc]initWithFrame:CGRectMake(15, 200, 100, 25)];
        lbl3.text=@"设置";
        lbl3.backgroundColor=[UIColor clearColor];
        lbl3.textColor=[UIColor whiteColor];
        lbl3.font=[UIFont boldSystemFontOfSize:13];
        lbl3.textAlignment=NSTextAlignmentLeft;
        [self addSubview:lbl3];
        [lbl3 release];
        
        line=[[LineView alloc]initWithFrame:CGRectMake(0, 90, self.frame.size.width, 100)];
        [self addSubview:line];
        [line release];
        
        UIView *view1=[[UIView alloc]initWithFrame:CGRectMake(85, 280, self.frame.size.width-170, 10)];
        view1.backgroundColor=[UIColor whiteColor];
       // view1.layer.cornerRadius=5;
        [view1.layer setMasksToBounds:NO];
        [self addSubview:view1];
        [view1 release];
        
        view2=[[UIView alloc]initWithFrame:CGRectMake(85, 280, 0, 10)];
        view2.backgroundColor=[UIColor blackColor];
       // view2.layer.cornerRadius=5;
        [view2.layer setMasksToBounds:NO];
        [self addSubview:view2];
        [view2 release];
        
        moveImage=[[UIImageView alloc]initWithFrame:CGRectMake(85, 230, 85, 59)];
        moveImage.image=[UIImage imageNamed:@"p滑块.png"];
        moveImage.userInteractionEnabled=YES;
        [self addSubview:moveImage];
        [moveImage release];
        
        xx = moveImage.center.x;
        
        UIPanGestureRecognizer *panGesturemoveImage = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panGesturemoveImage:)];
        [panGesturemoveImage setMaximumNumberOfTouches:2];
        [moveImage addGestureRecognizer:panGesturemoveImage];
        [panGesturemoveImage release];
        
        for (int i=0; i<[arrColors count]; i++) {
            UIButton *colorBtn=[[UIButton alloc]initWithFrame:CGRectMake(35+45*i, 330, 35, 35)];
            colorBtn.tag=10+i;
            colorBtn.backgroundColor=(UIColor *)[arrColors objectAtIndex:i];
            [colorBtn addTarget:self action:@selector(colorBtnAction:) forControlEvents:UIControlEventTouchDown];
            [self addSubview:colorBtn];
            [colorBtn release];
        }
        
        colorImageView=[[UIImageView alloc]initWithFrame:CGRectMake(10, 380, 399, 132)];
        colorImageView.image=[UIImage imageNamed:@"p取色.png"];
        colorImageView.userInteractionEnabled=YES;
        [self addSubview:colorImageView];
        [colorImageView release];
        
    }
    return self;
}

- (UIColor*) getPixelColorAtLocation:(CGPoint)point {
	UIColor* color = nil;
	CGImageRef inImage = colorImageView.image.CGImage;
	// Create off screen bitmap context to draw the image into. Format ARGB is 4 bytes for each pixel: Alpa, Red, Green, Blue
	CGContextRef cgctx = [self createARGBBitmapContextFromImage:inImage];
	if (cgctx == NULL) { return nil; /* error */ }
	
    size_t w = CGImageGetWidth(inImage);
	size_t h = CGImageGetHeight(inImage);
	CGRect rect = {{0,0},{w,h}};
	
	// Draw the image to the bitmap context. Once we draw, the memory
	// allocated for the context for rendering will then contain the
	// raw image data in the specified color space.
	CGContextDrawImage(cgctx, rect, inImage);
	
	// Now we can get a pointer to the image data associated with the bitmap
	// context.
	unsigned char* data = CGBitmapContextGetData (cgctx);
	if (data != NULL) {
		//offset locates the pixel in the data from x,y.
		//4 for 4 bytes of data per pixel, w is width of one row of data.
		int offset = 4*((w*round(point.y))+round(point.x));
		int alpha =  data[offset];
		int red = data[offset+1];
		int green = data[offset+2];
		int blue = data[offset+3];
		//NSLog(@"offset: %i colors: RGB A %i %i %i  %i",offset,red,green,blue,alpha);
		color = [UIColor colorWithRed:(red/255.0f) green:(green/255.0f) blue:(blue/255.0f) alpha:(alpha/255.0f)];
	}
	
	// When finished, release the context
	CGContextRelease(cgctx);
	// Free image data memory for the context
	if (data) { free(data); }
	
	return color;
}



- (CGContextRef) createARGBBitmapContextFromImage:(CGImageRef) inImage {
	
	CGContextRef    context = NULL;
	CGColorSpaceRef colorSpace;
	void *          bitmapData;
	int             bitmapByteCount;
	int             bitmapBytesPerRow;
	
	// Get image width, height. We'll use the entire image.
	size_t pixelsWide = CGImageGetWidth(inImage);
	size_t pixelsHigh = CGImageGetHeight(inImage);
	
	// Declare the number of bytes per row. Each pixel in the bitmap in this
	// example is represented by 4 bytes; 8 bits each of red, green, blue, and
	// alpha.
	bitmapBytesPerRow   = (pixelsWide * 4);
	bitmapByteCount     = (bitmapBytesPerRow * pixelsHigh);
	
	// Use the generic RGB color space.
	colorSpace = CGColorSpaceCreateDeviceRGB();
    
	if (colorSpace == NULL)
	{
		fprintf(stderr, "Error allocating color space\n");
		return NULL;
	}
	
	// Allocate memory for image data. This is the destination in memory
	// where any drawing to the bitmap context will be rendered.
	bitmapData = malloc( bitmapByteCount );
	if (bitmapData == NULL)
	{
		fprintf (stderr, "Memory not allocated!");
		CGColorSpaceRelease( colorSpace );
		return NULL;
	}
	
	// Create the bitmap context. We want pre-multiplied ARGB, 8-bits
	// per component. Regardless of what the source image format is
	// (CMYK, Grayscale, and so on) it will be converted over to the format
	// specified here by CGBitmapContextCreate.
	context = CGBitmapContextCreate (bitmapData,
									 pixelsWide,
									 pixelsHigh,
									 8,      // bits per component
									 bitmapBytesPerRow,
									 colorSpace,
									 kCGImageAlphaPremultipliedFirst);
	if (context == NULL)
	{
		free (bitmapData);
		fprintf (stderr, "Context not created!");
	}
	
	// Make sure and release colorspace before returning
	CGColorSpaceRelease( colorSpace );
	
	return context;
}

- (void) touchesEnded:(NSSet*)touches withEvent:(UIEvent*)event {
    
    
	
	UITouch* touch = [touches anyObject];
    if (touch.view==colorImageView) {
        CGPoint point = [touch locationInView:colorImageView]; //where image was tapped

        currcolor=[self getPixelColorAtLocation:point];
        if (setDelegate&&[setDelegate respondsToSelector:@selector(changeColor:)]) {
            [setDelegate changeColor:currcolor];
        }
        view2.backgroundColor=currcolor;
        line.currentColor=currcolor;
        [line setNeedsDisplay];
    }
   
}
-(void)panGestureBack:(UIPanGestureRecognizer *)gestureRecognizer{

    UIView *piece = [[gestureRecognizer view] superview];
	if ([gestureRecognizer state] == UIGestureRecognizerStateBegan || [gestureRecognizer state] == UIGestureRecognizerStateChanged) {
        
        [[self superview] bringSubviewToFront:self];
        
		CGPoint translation = [gestureRecognizer translationInView:[piece superview]];
        [piece setCenter:CGPointMake([piece center].x + translation.x, [piece center].y+ translation.y)];
        
        CGRect rect=piece.frame;
        if (rect.origin.y<=0) {
            rect.origin.y=0;
        }
        if (rect.origin.x<=0) {
            rect.origin.x=0;
        }
        if (rect.origin.x+rect.size.width>=1024) {
            rect.origin.x=1024-rect.size.width;
        }
        if (rect.origin.y+rect.size.height>=748) {
            rect.origin.y=748-rect.size.height;
        }
        
        
        piece.frame=rect;
        
		[gestureRecognizer setTranslation:CGPointZero inView:[piece superview]];
	}
}
-(void)panGesturemoveImage:(UIPanGestureRecognizer *)gestureRecognizer{
    
    UIView *piece = [gestureRecognizer view];
	if ([gestureRecognizer state] == UIGestureRecognizerStateBegan || [gestureRecognizer state] == UIGestureRecognizerStateChanged) {
        
		CGPoint translation = [gestureRecognizer translationInView:[piece superview]];
        [piece setCenter:CGPointMake([piece center].x + translation.x, [piece center].y)];
        view2.frame=CGRectMake(85, view2.frame.origin.y, view2.frame.size.width+ translation.x,view2.frame.size.height);
        
        if (piece.frame.origin.x<=85) {
             view2.frame=CGRectMake(85, view2.frame.origin.y, 0,view2.frame.size.height);
            piece.frame=CGRectMake(85, piece.frame.origin.y, piece.frame.size.width, piece.frame.size.height);
        }
        if(piece.frame.origin.x>=(self.frame.size.width-85)){
            
            view2.frame=CGRectMake(85, view2.frame.origin.y, self.frame.size.width-170,view2.frame.size.height);
            piece.frame=CGRectMake(self.frame.size.width-85, piece.frame.origin.y, piece.frame.size.width, piece.frame.size.height);
        }
        
        width = (view2.frame.size.width*18.0/(self.frame.size.width-170))+2;
        
        NSLog(@" fsf %f *** %f",view2.frame.size.width,width);
       
        
        
        if (setDelegate&&[setDelegate respondsToSelector:@selector(changeWidth:)]) {
            [setDelegate changeWidth:width];
        }
        
        line.width=width;
        [line setNeedsDisplay];
		[gestureRecognizer setTranslation:CGPointZero inView:[piece superview]];
	}
}

-(void)colorBtnAction:(UIButton *)btn{
    currcolor=(UIColor *)[arrColors objectAtIndex:btn.tag-10];
    if (setDelegate&&[setDelegate respondsToSelector:@selector(changeColor:)]) {
        [setDelegate changeColor:currcolor];
    }
    view2.backgroundColor=currcolor;
    line.currentColor=currcolor;
    [line setNeedsDisplay];
    
}



-(void)setNeedsDisplayView{
    
    
    float r,g,b;
    r = [[[NSUserDefaults standardUserDefaults]objectForKey:@"color_r"] floatValue];
    g = [[[NSUserDefaults standardUserDefaults]objectForKey:@"color_g"] floatValue];
    b = [[[NSUserDefaults standardUserDefaults]objectForKey:@"color_b"] floatValue];
    UIColor *color = [UIColor colorWithRed:r green:g blue:b alpha:1];
    line.currentColor = color;
    view2.backgroundColor = color;
    
    line.width = [[[NSUserDefaults standardUserDefaults] objectForKey:@"width"] floatValue];
    [line setNeedsDisplay];
    
    
    float view2width =  (line.width-2)*1.0*(self.frame.size.width - 170)/18;    
    NSLog(@"aaaa %f",view2width);
    view2.frame = CGRectMake(view2.frame.origin.x, view2.frame.origin.y, view2width, view2.frame.size.height);
    moveImage.frame = CGRectMake(85+view2width, moveImage.frame.origin.y, moveImage.frame.size.width, moveImage.frame.size.height);
}

-(void)dealloc{
    //[currcolor release];
    [arrColors release];
    [super dealloc];
}
-(void)closeBtnAction{
    
    self.hidden=YES;
}


/*
// Only override drawRect: if you perform custom drawing.
// An empty implementation adversely affects performance during animation.
- (void)drawRect:(CGRect)rect
{
    // Drawing code
}
*/

@end
